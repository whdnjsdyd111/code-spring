            17.1 프로젝트 구성


            17.2 댓글 처리를 위한 영속 영역

댓글 추가를 위해 댓글 구조의 테이블을 설계한다. 댓글 테이블은 tbl_reply 란 테이블로 지정하여 생성한다.


    CREATE TABLE tbl_reply (
      rno NUMBER(10, 0),
      bno NUMBER(10, 0) NOT NULL,
      reply VARCHAR2(1000) NOT NULL,
      replyer VARCHAR2(50) NOT NULL,
      replyDate DATE DEFAULT SYSDATE,
      updateDate DATE DEFAULT SYSDATE
    );

    CREATE SEQUENCE seq_reply;

    ALTER TABLE tbl_reply ADD CONSTRAINT pk_reply PRIMARY KEY(rno);

    ALTER TABLE tbl_reply ADD CONSTRAINT fk_reply_board
    FOREIGN KEY(bno) REFERENCES tbl_board(bno);


tbl_reply 테이블은 bno 컬럼으로 해당 댓글이 어느 게시물의 댓글인지 명시한다.
댓글 자체는 단독 CRUD 가 가능하므로, 별도의 PK 를 부여하도록 하고 외래키(KF) 설정을 통해 tbl_board 테이블을 참조하도록 한다.


        17.2.1 ReplyVO 클래스의 추가

'src/main/java/domain' 패키지에 ReplyVO 클래스를 추가한다.


    import lombok.Data;

    import java.util.Date;

    @Data
    public class ReplyVO {
        private long rno;
        private long bno;

        private String reply;
        private String replyer;
        private Date replyDate;
        private Date updateDate;
    }


        17.2.2 ReplyMapper 클래스와 XML 처리

'src/main/java/mapper' 패키지에 ReplyMapper 인터페이스를 처리하고, XML 파일 역시 생성한다.


    public interface ReplyMapper {
    }


페이지 처리가 필요할 수 있으니 Criteria 를 이용해서 처리하도록 한다.
실제 SQL 은 'src/main/resources/mapper' 폴더 아래에 ReplyMapper.xml 파일을 작성하여 처리한다.


    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE mapper
            PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
            "http://mybatis.org/schema/mybatis-3-mapper.dtd">
    <mapper namespace="mapper.ReplyMapper">

    </mapper>


CRUD 작업 테스트 전 tbl_reply 테이블이 tbl_board 테이블과 FK(외래키)의 관계인 것을 인지해야 한다.

tbl_reply 가 tbl_board 테이블의 bno 값과 정확히 일치해야 하므로 테스트 진행 전
최신 bno 번호 몇 개를 예제로 확인한다.


    ReplyMapper 테스트

우선 ReplyMapper 가 사용 가능한지 테스트 작업을 진행한다. 이를 위해 ReplyMapperTests 클래스를 작성한다.


    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration("file:src/main/webapp/WEB-INF/spring/root-context.xml")
    // @ContextConfiguration(classes = {RootConfig.class})
    @Log4j
    public class ReplyMapperTests {
        @Setter(onMethod_ = @Autowired)
        private ReplyMapper mapper;

        @Test
        public void testMapper() {
            log.info(mapper);
        }
    }


testMapper() 테스트를 통해 ReplyMapper 타입 객체가 정상 사용 가능한지 확인한다.


    org.apache.ibatis.binding.MapperProxy@5733f295


        17.2.3 CRUD 작업

ReplyMapper 를 이용한 CRUD 작업은 단일 테이블에 대한 작업과 유사하므로 등록, 수정, 삭제, 조회 작업을 처리한다.


    public interface ReplyMapper {
        public int insert(ReplyVO vo);
    }


ReplyMapper 의 SQL 을 처리하는 XMl 내용은 다음과 같다.


    <insert id="insert">
        INSERT INTO tbl_reply (rno, bno, reply, replyer)
        VALUES (seq_reply.NEXTVAL, #{bno}, #{reply}, #{replyer})
    </insert>


테스트 코드는 기존 존재하는 게시물 번호(bno)를 사용하여 ReplyVO 를 작성한다.


    public class ReplyMapperTests {
        @Setter(onMethod_ = @Autowired)
        private ReplyMapper mapper;

        // 테스트 전에 해당 번호의 게시물이 존재하는지 확인
        private Long[] bnoArr = { 983052L, 983051L, 983050L, 983049L, 983048L };

        @Test
        public void testMapper() {
            log.info(mapper);
        }

        @Test
        public void testCreate() {
            IntStream.rangeClosed(1, 10).forEach(i -> {
                ReplyVO vo = new ReplyVO();

                // 게시물 번호
                vo.setBno(bnoArr[i % 5]);
                vo.setReply("댓글 테스트 " + i);
                vo.setReplyer("replyer" + i);

                mapper.insert(vo);
            });
        }
    }


ReplyMapperTests 내부에 bnoArr 게시물 번호들로 실제 데이터베이스의 번호들을 사용한다.
테스트가 정삭 작동되는지 확인하자.


    SELECT * FROM tbl_reply ORDER BY rno DESC;


등록 작업 후 조회 작업을 처리한다.


    조회(read)

ReplyMapper 인터페이스와 ReplyMapper.xml 에 조회 처리를 추가한다.


    ReplyMapper 인터페이스

    public ReplyVO read(Long rno);


    ReplyMapper.xml

    <select id="read" resultType="domain.ReplyVO">
        SELECT * FROM tbl_reply WHERE rno = #{rno}
    </select>


테스트 코드는 tbl_reply 의 번호 중 하나로 확인한다.


    @Test
    public void testRead() {
        Long targetRno = 5L;

        ReplyVO vo = mapper.read(targetRno);

        log.info(vo);
    }


테스트 결과 5번 댓글이 정상 조회되는지 확인한다.


    ReplyVO(rno=5, bno=983052, reply=댓글 테스트 5, replyer=replyer5,
    replyDate=Sun Jan 17 12:27:23 KST 2021, updateDate=Sun Jan 17 12:27:23 KST 2021)


    삭제(delete)

특정 댓글 삭제는 댓글 번호(rno)만으로 처리 가능하다.


    ReplyMapper 인터페이스

    public int delete(Long rno);


    ReplyMapper.xml

    <delete id="delete">
        DELETE FROM tbl_reply WHERE rno = #{rno}
    </delete>


    ReplyMapperTests 클래스

    @Test
    public void testDelete() {
        Long targetRno = 1L;

        mapper.delete(targetRno);
    }


    jdbc.sqltiming - DELETE FROM tbl_reply WHERE rno = 1


    수정(update)

댓글 수정은 tbl_reply 테이블 구조에 댓글 내용과 최종 수정(updateDate)를 수정한다.


    ReplyMapper 인터페이스

    public int update(ReplyVO reply);


    ReplyMapper.xml

    <update id="update">
        UPDATE tbl_reply SET reply = #{reply}, updateDate = SYSDATE WHERE rno = #{rno}
    </update>


    ReplyMapperTests 클래스

    @Test
    public void testUpdate() {
        Long targetRno = 10L;

        ReplyVO vo = mapper.read(targetRno);

        vo.setReply("Update Reply ");

        int count = mapper.update(vo);

        log.info("UPDATE COUNT: " + count);
    }


    jdbc.sqltiming - UPDATE tbl_reply SET reply = 'Update Reply ', updateDate = SYSDATE WHERE rno = 10


        17.2.4 @Param 어노테이션과 댓글 목록

댓글 목록은 게시물 페이징 처리와 비슷하지만 추가적으로 특정 게시물의 댓글만 대상하여 게시물의 번호가 필요하다.
MyBatis 는 두 개 이상의 데이터를 파라미터로 전달하기 위해 별도의 객체로 구성하거나, Map 을 이용, @Param 을 이용한 방식이 있다.

여러 방식 중 @Param 방식을 하용하며 @Param 의 속성값은 MyBatis 에서 SQL 이용할 때 '#{}' 의 이름으로 사용이 가능하다.

페이징 처리는 기존처럼 Criteria 를 이용한다. 여기에 추가로 게시물 번호를 파라미터로 전달하도록 ReplyMapper 를 구성한다.


    public List<ReplyVO> getListWithPaging(
            @Param("cri") Criteria cri,
            @Param("bno") Long bno
    );


XML 처리 시 지정된 'cri' 와 'bno' 모두 사용할 수 있다.

댓글도 페이징 처리를 해 줄 수 있는데, 뒤쪽에서 처리하며 지금은 특정 게시물의 댓글을 가져오도록 작성한다.


    <select id="getListWithPaging" resultType="domain.ReplyVO">
        SELECT rno, bno, reply, replyer, replyDate, updateDate
        FROM tbl_reply WHERE bno = #{bno} ORDER BY rno ASC
    </select>


위 '#{bno}' 는 @Param("bno") 와 매칭된다는 점을 주의하자.
테스트 코드에서 현재 데이터베이스에 추가된 댓글들의 게시물 번호를 확인한다.


    @Test
    public void testList() {
        Criteria cri = new Criteria();

        // 983052L
        List<ReplyVO> replies = mapper.getListWithPaging(cri, bnoArr[0]);

        replies.forEach(reply -> log.info(reply));
    }


    INFO : mapper.ReplyMapperTests - ReplyVO(rno=5, bno=983052, reply=댓글 테스트 5, replyer=replyer5,
    replyDate=Sun Jan 17 12:27:23 KST 2021, updateDate=Sun Jan 17 12:27:23 KST 2021)
    INFO : mapper.ReplyMapperTests - ReplyVO(rno=10, bno=983052, reply=Update Reply , replyer=replyer10,
    replyDate=Sun Jan 17 12:27:23 KST 2021, updateDate=Sun Jan 17 12:55:24 KST 2021)


            17.3 서비스 영역과 Controller 처리

서비스 영역과 Controller 처리는 기존 BoardService 와 동일하게 ReplyService 인터페이스와 ReplyServiceImpl 클래스를 작성한다.


    import domain.Criteria;
    import domain.ReplyVO;

    import java.util.List;

    public interface ReplyService {
        public int register(ReplyVO vo);

        public ReplyVO get(Long rno);

        public int modify(ReplyVO vo);

        public int remove(Long rno);

        public List<ReplyVO> getList(Criteria cri, Long bno);
    }


ReplyService 를 구현하는 ReplyServiceImpl 클래스에는 @Service 어노테이션과 @Log 를 적용한다.


    import domain.Criteria;
    import domain.ReplyVO;
    import lombok.Setter;
    import lombok.extern.java.Log;
    import mapper.ReplyMapper;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;

    import java.util.List;

    @Service
    @Log
    public class ReplyServiceImpl implements ReplyService {
        @Setter(onMethod_ = @Autowired)
        private ReplyMapper mapper;

        @Override
        public int register(ReplyVO vo) {
            log.info("register ... " + vo);

            return mapper.insert(vo);
        }

        @Override
        public ReplyVO get(Long rno) {
            log.info("get ... " + rno);

            return mapper.read(rno);
        }

        @Override
        public int modify(ReplyVO vo) {
            log.info("modify ... " + vo);

            return mapper.update(vo);
        }

        @Override
        public int remove(Long rno) {
            log.info("remove ... " + rno);

            return mapper.delete(rno);
        }

        @Override
        public List<ReplyVO> getList(Criteria cri, Long bno) {
            log.info("get Reply list of a Board " + bno);

            return mapper.getListWithPaging(cri, bno);
        }
    }


ReplyServiceImpl 은 ReplyMapper 와 의존 관계로 @Setter 를 이용하여 처리하거나 스프링 4.3 생성자와 자동 주입으로
아래와 같이 처리할 수 있다.


    @Service
    @Log
    @AllArgsConstructor
    public class ReplyServiceImpl implements ReplyService {
        private ReplyMapper mapper;
        ...


        17.3.1 ReplyController 의 설계

ReplyController 앞의 예제엔 SampleController 와 유사히 @RestController 어노테이션으로 설계하여
다음 RUI 을 기준으로 동작하게 작성한다.


    작업  URL                         HTTP 전송방식

    등록  /replies/new                POST

    조회  /replies/:rno               GET

    삭제  /replies/:rno               DELETE

    수정  /replies/:rno               PUT or PATCH

    페이지 /replies/pages/:bno/:page   GET


REST 방식으로 URL 설계 시 PK 를 기준으로 작성하는 것이 좋다. PK 만으로 조회, 수정, 삭제가 가능하기 때문이다.
댓글 목록은 PK를 사용할 수 없기 때문에 게시물 번호(bno) 와 페이지 번호(page) 정보를 URL 에 표현하는 방식을 사용한다.

ReplyController 는 ReplyService 타입의 객체인 ReplyServiceImpl 객체를 주입받도록 설계한다.


    @RequestMapping("/replies")
    @RestController
    @Log
    @AllArgsConstructor
    public class ReplyController {
        private ReplyService service;
    }


@Setter 주입이나 @AllArgsConstructor 를 이용하여 ReplyService 객체를 자동 주입하도록 한다.


        17.3.2 등록 작업과 테스트

REST 방식으로 처리할 때 주의 점은 외부에서 서버 호출 시 데이터 포맷과 서버에서 보내주는 데이터 타입을 명확히 설계해야 하는 것이다.
예로 댓글 등록의 경우 브라우저에선 JSON 타입으로 댓글 데이터를 전송하고, 서ㅓㅂ에서 댓글 처리 결과가 정상적으로 됐는지
문자열로 결과를 알려주도록 한다.


    @PostMapping(value = "/new", consumes = "application/json", produces = {MediaType.TEXT_PLAIN_VALUE})
    public ResponseEntity<String> create(@RequestBody ReplyVO vo) {
        log.info("ReplyVO: " + vo);

        int insertCount = service.register(vo);

        log.info("Reply INSERT COUNT: " + insertCount);

        return insertCount == 1
                ? new ResponseEntity<>("success", HttpStatus.OK)
                : new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
        // 삼항 연산자 처리
    }


create() 는 @PostMapping 으로 POST 방식으로만 동작하도록 설계하고, consumes 와 produces 를 이용해서
JSON 방식의 데이터만 처리하도록 하고, 문자열을 반환하도록 설계한다. create() 의 파라미터는 @RequestBody 를 적용하여
JSON 데이터를 ReplyVO 타입으로 변환하도록 지정한다.

create() 는 내부적으로 ReplyServiceImpl 를 호출하여 register()를 호출하고, 댓글이 추가된 숫자를 확인하여
브라우저에서 '200 OK' 혹은 '500 Internal Server Error' 를 반환하도록 한다.

테스트 시에 POST 방식으로 전송하고, 'Content-Type' 은 'application/json' 으로 지정해야 한다.
실제 전송되는 데이터는 존재하는 게시물 번호(bno)와 댓글 내용(reply), 댓글 작성자(replyer)를 JSON 문법에 맞게 작성하도록 주의한다.
게시물 번호는 기존 존재하는 번호여야 하는 주의가 필요하다.


    {"bno": 983052, "reply": "Hello Reply", "replyer": "user00"}


작성된 댓글은 데이터베이스에 정상 추가되었는지 확인한다.


        17.3.3 특정 게시물의 댓글 목록 확인

특정 게시물의 댓글 목록을 확인하는 작업은 아래와 같이 작성한다.


    @GetMapping(value = "/pages/{bno}/{page}", produces = {MediaType.APPLICATION_XML_VALUE,
            MediaType.APPLICATION_JSON_UTF8_VALUE})
    public ResponseEntity<List<ReplyVO>> getList(
            @PathVariable("page") int page,
            @PathVariable("bno") Long bno) {
        log.info("getList ...");

        Criteria cri = new Criteria(page, 10);
        log.info(cri.toString());

        return new ResponseEntity<>(service.getList(cri, bno), HttpStatus.OK);
    }


ReplyController 의 getList() 는 Criteria 를 이용해서 파라미터를 수집하는데, '/{bno}/{page}' 의
'page' 값은 Criteria 를 생성해서 직접 처리해야 한다. 게시물의 번호는 @PathVariable 을 이용하여 파라미터로 처리하고
아래 테스트를 해본다.


    http://localhost:8000/replies/pages/983052/1


테스트 결과는 XML 타입으로 댓글 데이터들을 확인할 수 있다. 만일 JSON 타입을 원할 시 마지막에 '.json' 을 추가하면 된다.


        17.3.4 댓글 삭제/조회

RestController 의 댓글의 수정/삭제/조회는 위와 유사한 방식으로 JSON 이나 문자열을 반환하도록 설계한다.


    @GetMapping(value = "/{rno}", produces = {MediaType.APPLICATION_XML_VALUE,
            MediaType.APPLICATION_JSON_UTF8_VALUE})
    public ResponseEntity<ReplyVO> get(@PathVariable("rno") Long rno) {
        log.info("get: " + rno);

        return new ResponseEntity<>(service.get(rno), HttpStatus.OK);
    }

    @DeleteMapping(value = "/{rno}", produces = {MediaType.TEXT_PLAIN_VALUE})
    public ResponseEntity<String> remove(@PathVariable("rno") Long rno) {
        log.info("remove: " + rno);

        return service.remove(rno) == 1
                ? new ResponseEntity<>("success", HttpStatus.OK)
                : new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
    }


        17.3.5 댓글 수정

댓글 수정은 JSON 형태로 전달되는 데이터와 파라미터로 전달되는 댓글 번호(rno)를 처리하기 때문에 아래같이 처리한다.


    @RequestMapping(method = {RequestMethod.PUT, RequestMethod.PATCH},
            value = "/{rno}",
            consumes = "application/json",
            produces = {MediaType.TEXT_PLAIN_VALUE})
    public ResponseEntity<String> modify(
            @RequestBody ReplyVO vo,
            @PathVariable("rno") Long rno) {
        vo.setRno(rno);

        log.info("rno: " + rno);
        log.info("modify: " + vo);

        return service.modify(vo) == 1
                ? new ResponseEntity<>("success", HttpStatus.OK)
                : new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
    }


댓글 수정은 'PUT' 이나 'PATCH' 방식으로 처리하고, 실제 수정되는 데이터는 JSON 포맷으로 @RequestBody 를 이용하여 처리한다.
@RequestBody 로 처리되는 데이터는 일반 파리미터나 @PathVariable 파라미터로 처리할 수 없어 직접 처리해 주는 부분을 주의한다.


            17.4 JavaScript 준비

JSP 내에 댓글 처리는 한 페이지 내에 모든 작업이 이루어져 복잡하게 느낄 수 있다.
기존과 달리 JavaScript 와 동적으로 만들어지는 HTML 로 처리하기 때문에 각 단계에 주의한다.


        17.4.1 JavaScript 모듈화

jQuery 는 막강한 기능과 플러그인을 통해 많은 프로젝트에서 사용하는데, 특히 Ajax 를 jQuery 함수로 쉽게 처리할 수 있다.
화면 내에 JavaScript 로 이벤트 처리, DOM 처리, Ajax 처리 등으로 유지보수 하기 힘든 코드를 만드는 경우가 많은데
이 경우를 대비하여 JavaScript 를 하나의 모듈처럼 구성하는 방식을 이용하는 것이 좋다.
JavaScript 에서 가장 많이 사용하는 패턴이 모듈 패턴이며 쉽게 말하면 함수들의 묶음이다.
JavaScript 클로저가 가장 대표적인 방법이다.

webapp 내 resources 폴더에 js 폴더 내 reply.js 파일을 작성한다.


    console.log("Reply Module...");

    var replyService = {};


reply.js 파일은 게시물 조회 페이지에서 사용하므로 views/board/get.jsp 파일에 추가한다.


    <script type="text/javascript" src="${pageContext.request.contextPath}/resources/js/reply.js"></script>


reply.js 정상 동작하는지 '/board/get?bno=xxx' 번호를 호출하여 reply.js 가 실행되는지 확인한다.


    모듈 구성하기

모듈 패턴은 Java 클래스처럼 JavaScript 로 메소드를 가지는 객체로 구성한다.
모듈 패턴은 JavaScript 로 즉시 실행함수와 '{}' 를 이용하여 객체를 구성한다.


    console.log("Reply Module...");

    var replyService = (function() {
        return {name: "AAAA"};
    })();


즉시 실행함수는 () 안에 함수 선언 후 바깥에서 실행해 버린다.
즉 함수 실행 결과가 바깥에 선언된 변수에 할당된다. 위 코드에선 replyService 란 변수에 name 이란 속성에 'AAAA' 속성값이 할당된다.

replyService 의 확인은 reply.js 를 사용하는 get.jsp 에서 확인한다.


    <script type="text/javascript">
        $(document).ready(function() {
            console.log(replyService);
        })
    </script>


        17.4.2 reply.js 등록 처리

모듈 패턴은 즉시 실행하는 함수 내부에 필요한 메소드를 구성해서 객체를 구성하는 방식이다. 코드는 다음과 같다.


    console.log("Reply Module...");

    var replyService = (function() {
        function add(reply, callback) {
            console.log("reply ...");
        }

        return {add: add};
    })();


외부에서 replyService.add(객체, 콜백)를 전달하는 형태로 호출하며, Ajax 호출은 감춰져 있어 코드를 좀 더 깔끔하게 할 수 있다.

reply.js 내에 add 함수는 Ajax 를 이용하여 POST 방식으로 호출하는 코드를 작성한다.


    console.log("Reply Module...");

    var replyService = (function() {
        function add(reply, callback, error) {
            console.log("reply ...");

            $.ajax({
                type: 'post',
                url: '/replies/new',
                data: JSON.stringify(reply),
                contentType: "application/json; charset=utf-8",
                success: function(result, status, xhr) {
                    if(callback) {
                        callback(result);
                    }
                },
                error: function(xhr, status, er) {
                    if(error) {
                        error(er);
                    }
                }
            })
        }

        return {add: add};
    })();


add() 는 데이터 전송 타입이 'application/json; charset=utf-8' 방식으로 전송하며
파라미터로 callback 과 error 를 함수로 받을 것이란 점이다.
만일 Ajax 호출이 성공하고, callback 값으로 적절한 함수가 존재하면 해당 함수를 호출하여 결과를 반영하는 방식이다.

JavaScript 는 특이하게 파라미터 개수를 일치시킬 필요 없어서 callback 이나 error 파라미터는 필요할 때만 작성할 수 있다.
reply.js 를 이용하는 get.jsp 에선 테스트를 위해 replyService.add() 를 호출해보자.


    <script type="text/javascript">

        console.log("==========")
        console.log("JS TEST");

        var bnoValue = '<c:out value="${board.bno}"/>';

        // for replyService add test
        replyService.add(
            {reply: "JS Test", replyer: "tester", bno: bnoValue},
            function(result) {
                alert("RESULT: " + result);
            }
        );

    </script>


get.jsp 내부에서 Ajax 호출은 replyService 이름의 객체로 감춰져 있어 필요한 파라미터만 전달하였다.
replyService 의 add() 에 던질 파라미터는 JavaScript 객체 타입으로 만들어 전송하고, Ajax 전송 결과를 처리하는 함수를
파라미터로 같이 전달한다.
톰캣을 실행하여 결과를 확인할 때 데이터베이스에 정상적으로 글이 추가되고 경고창이 떠야한다.


    register ... ReplyVO(rno=0, bno=983052, reply=JS Test, replyer=tester, replyDate=null, updateDate=null)


        17.4.3 댓글의 목록 처리

이제 댓글 전체 목록을 가져온다. 최종적으로 페이징 처리하며, 우선 전체 댓글을 가져온다.
톰캣 실행 중이면 '/replies/pages/게시물번호/페이지번호.xml' 혹은 '/replies/pages/게시물번호/페이지번호.json'
데이터를 먼저 확인한다.


    getJSON() 사용

reply.js 에서 Ajax 호출을 담당하니 getJSON() 으로 처리할 수 있다.


    console.log("Reply Module...");

    var replyService = (function() {
        function add(reply, callback, error) {
            console.log("reply ...");

            ...
        }

        function getList(param, callback, error) {
            var bno = param.bno;
            var page = param.page || 1;
            $.getJSON("/replies/pages/" + bno + "/" + page + ".json",
                function(data) {
                    if(callback) {
                        callback(data);
                    }
                }).fail(function(xhr, status, err) {
                if(error) {
                    error();
                }
            });
        }

        return {
            add: add,
            getList: getList
        };
    })();


getList() 는 param 이란 객체로 필요한 파라미터를 전달받아 JSON 목록을 호출한다. 이는 JSON 형태가 필요하여
'.json' 으로 요구한다.

댓글 등록도 get.jsp 에서 해당 게시물의 모든 댓글을 가져오는지 확인하는 코드를 작성해 본다.


    <script type="text/javascript">

        console.log("==========")
        console.log("JS TEST");

        var bnoValue = '<c:out value="${board.bno}"/>';

        // reply List test
        replyService.getList({bno: bnoValue, page: 1}, function(list) {
            for(let i = 0, len = list.length || 0; i < len; i++) {
                console.log(list[i]);
            }
        });

    </script>


        17.4.4 댓글 삭제와 갱신

댓글 삭제는 DELETE 방식으로 해당 URL 을 호출한다.


    console.log("Reply Module...");

    var replyService = (function() {
        function add(reply, callback, error) {
            ...
        }

        function getList(param, callback, error) {
            ...
        }

        function remove(rno, callback, error) {
            $.ajax({
                type: 'delete',
                url: '/replies/' + rno,
                success: function(deleteResult, status, xhr) {
                    if(callback) {
                        callback(deleteResult);
                    }
                },
                error: function(xhr, status, er) {
                    if(error) {
                        error(er);
                    }
                }
            })
        }

        return {
            add: add,
            getList: getList,
            remove: remove
        };
    })();


remove()는 DELETE 방식으로 데이터를 전달하므로, $.ajax() 을 구체적으로 'delete' 로 지정한다.
board/get.jsp 에선 실제 데이터베이스의 댓글 번호를 이용하여 댓글이 삭제되었는지 확인한다.


    <script type="text/javascript">

        console.log("==========")
        console.log("JS TEST");

        var bnoValue = '<c:out value="${board.bno}"/>';

        // 12번 댓글 삭제 테스트
        replyService.remove(12, function(count) {
            console.log(count);

            if(count === 'success') {
                alert("REMOVED");
            }
        }, function(err) {
            alert("ERROR...");
        });

    </script>


12번 댓글이 삭제되는지 데이터베이스에서 확인해본다.


        17.4.5 댓글 수정

댓글 수정은 내용과 함께 댓글 번호를 전송한다. 댓글 내용은 JSON 형태로 전송하여 댓글 등록과 유사하다.


    console.log("Reply Module...");

    var replyService = (function() {
        function add(reply, callback, error) {
            ...
        }

        function getList(param, callback, error) {
            ...
        }

        function remove(rno, callback, error) {
            ...
        }

        function update(reply, callback, error) {
            console.log("RNO: " + reply.rno);

            $.ajax({
                type: 'put',
                url: '/replies/' + reply.rno,
                data: JSON.stringify(reply),
                contentType: "application/json; charset=utf-8",
                success: function(result, status, xhr) {
                    if(callback) {
                        callback(result);
                    }
                },
                error: function(xhr, status, er) {
                    if(error) {
                        error(er);
                    }
                }
            });
        }

        return {
            add: add,
            getList: getList,
            remove: remove,
            update: update
        };
    })();


replyService 이용하는 get.jsp 에 다음과 같은 방식으로 사용된다.


    <script type="text/javascript">

        console.log("==========")
        console.log("JS TEST");

        var bnoValue = '<c:out value="${board.bno}"/>';

        // 11번 댓글 수정
        replyService.update({
            rno: 22,
            bno: bnoValue,
            reply: "Modified Reply..."
        }, function(result) {
            alert("수정 완료...");
        });

    </script>


        17.4.6 댓글 조회 처리

특정 번호 댓글 조회는 GET 방식으로 동작하여 다음과 같이 reply.js 를 처리한다.


    console.log("Reply Module...");

    var replyService = (function() {
        function add(reply, callback, error) {
            ...
        }

        function getList(param, callback, error) {
            ...
        }

        function remove(rno, callback, error) {
            ...
        }

        function update(reply, callback, error) {
            ...
        }

        function get(rno, callback, error) {
            $.get("/replies/" + rno + ".json", function(result) {
                if(callback) {
                    callback(result);
                }
            }).fail(function(xhr, status, err) {
                if(error) {
                    error();
                }
            });
        }

        return {
            add: add,
            getList: getList,
            remove: remove,
            update: update,
            get: get
        };
    })();


get.jsp 에서 단순히 댓글 번호만 전달한다.


    <script type="text/javascript">

        console.log("==========")
        console.log("JS TEST");

        var bnoValue = '<c:out value="${board.bno}"/>';

        replyService.get(11, function(data) {
            console.log(data);
        });

    </script>


            17.5 이벤트 처리와 HTML 처리

모두 Ajax 처리가 완료되었다. 남은 작업은 화면 버튼 등 발생하는 이벤트 감지와 Ajax 호출의 결과를 화면에 반영하는 것이다.


        17.5.1 댓글 목록 처리

댓글 목록을 위해 별도로 <div> 를 생성하여 처리하며 게시물 아래에 추가한다.


    <div class="row">
        <div class="col-lg-12">
            <div class="card">
                <div class="card-header">
                    <i class="fa fa-comments fa-fw"></i> Reply
                </div>

                <div class="card-body">
                    <ul class="list-group">
                        <li class="list-group-item clearfix" data-rno="12">
                            <div>
                                <div class="header">
                                    <strong class="primary-font">user00</strong>
                                    <small class="float-right text-muted">2021-01-07 20:16</small>
                                </div>
                                <p>Good Job!</p>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>


댓글 목록은 <ul> 과 <li> 로 처리하며 하나의 댓글은 수정이나 삭제가 가능하게한다.
수정이나 삭제는 반드시 댓글 번호가 필요하니 'data-rno' 속성으로 처리한다.


    이벤트 처리

게시물의 조회 페이지가 열리면 자동으로 목록을 가져와서 구성해야 한다. 이 처리는 $(document).ready() 로 처리한다.


    <script type="text/javascript">

        console.log("==========")
        console.log("JS TEST");

        var bnoValue = '<c:out value="${board.bno}"/>';
        var replyUL = $('.list-group');

        showList(1);

        function showList(page) {
            replyService.getList({bno: bnoValue, page: page || 1}, function(list) {
                var str = "";
                if(list == null || list.length == 0) {
                    replyUL.html("");

                    return;
                }

                for(let i = 0, len = list.length || 0; i < len; i++) {
                    str += "<li class='list-group-item clearfix' data-rno='" + list[i].rno + "'>";
                    str += "<div><div class='header'><strong class='text-primary'>" + list[i].replyer + "</strong>";
                    str += "<small class='float-right text-muted'>" + list[i].replyDate + "</small></div>";
                    str += "<p>" + list[i].reply + "</p></div></li>";
                }

                replyUL.html(str);
            });
        }

    </script>


showList() 는 페이지 번호를 파라미터로 받게 설계하고, 파라미터가 없을 경우 자동 1 페이지를 지정한다.
DOM 처리 후 showList() 로 <ul> 태그의 내용을 처리한다.


    시간에 대한 처리

XML 이나 JSON 으로 순수하게 숫자로 표현된 시간 값이 나오게 되어있어 변환하는 것이 좋다.
날짜 포맷은 문화권마다 달라서 순서 등이 다르기 때문에 포맷 처리를 권장한다.

최근 해당일에 데이터는 '시/분/초' 를 보여주고 전날엔 '년/월/일' 을 보여주는 경우가 많다.
현재 시간을 기준으로 내용이 달라지도록 함수를 작성한다.


    console.log("Reply Module...");

    var replyService = (function() {
        function add(reply, callback, error) {
            ...
        }

        function getList(param, callback, error) {
            ...
        }

        function remove(rno, callback, error) {
            ...
        }

        function update(reply, callback, error) {
            ...
        }

        function get(rno, callback, error) {
            ...
        }

        function displayTime(timeValue) {
            var today = new Date();

            var gap = today.getTime() - timeValue;

            var dateObj = new Date(timeValue);

            var str = "";

            if(gap < (1000 * 60 * 60 * 24)) {
                var hh = dateObj.getHours();
                var mi = dateObj.getMinutes();
                var ss = dateObj.getSeconds();

                return [(hh > 9 ? '' : '0') + hh, ':', (mi > 9 ? '' : '0') + mi,
                    ':', (ss > 9 ? '' : '0') + ss].join('');
            } else {
                var yy = dateObj.getFullYear();
                var mm = dateObj.getMonth() + 1;
                var dd = dateObj.getDate();

                return [yy, '/', (mm > 9 ? '' : '0') + mm, '/',
                    (dd > 9 ? '' : '0') + dd].join('');
            }
        }

        return {
            add: add,
            getList: getList,
            remove: remove,
            update: update,
            get: get,
            displayTime: displayTime
        };
    })();


displayTime()은 Ajax 에서 데이터를 가져와서 HTML 을 만드는 부분에 'replyService.displayTime(list[i].replyDate)'
형태로 적용하게 한다.


    for(let i = 0, len = list.length || 0; i < len; i++) {
        str += "<li class='list-group-item clearfix' data-rno='" + list[i].rno + "'>";
        str += "<div><div class='header'><strong class='text-primary'>" + list[i].replyer + "</strong>";
        str += "<small class='float-right text-muted'>" + replyService.displayTime(list[i].replyDate) + "</small></div>";
        str += "<p>" + list[i].reply + "</p></div></li>";
    }


작성된 displayTime() 을 적용하면 24 시간 지난 댓글은 날짜만 표시되고, 24시간 이내 글은 시간으로 표시된다.


        17.5.2 새로운 댓글 처리

댓글 목록 상단에는 버튼을 하나 추가하여 사용자들이 새 댓글을 추가할 수 있도록 준비한다.


    <div class="card-header">
        <i class="fa fa-comments fa-fw"></i> Reply
        <button id="addReplyBtn" class="btn btn-primary btn-sm float-right">New Reply</button>
    </div>


댓글 추가는 모달창으로 진행한다. footer.jsp 에 모달이 포함되어 있으니 별도로 추가하진 않는다.


    <!-- Modal -->
    <div class="modal fade" id="replyModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel"
         aria-hidden="true">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exampleModalLabel">REPLY MODAL</h5>
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">×</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label>Reply</label>
                        <input class="form-control" name="reply" value="New Reply!!!">
                    </div>
                    <div class="form-group">
                        <label>Replyer</label>
                        <input class="form-control" name="replyer" value="replyer">
                    </div>
                    <div class="form-group">
                        <label>Reply Date</label>
                        <input class="form-control" name="replyDate" value="">
                    </div>
                </div>
                <div class="modal-footer">
                    <button id="modalModBtn" type="button" class="btn btn-warning">Modify</button>
                    <button id="modalRemoveBtn" type="button" class="btn btn-danger">Remove</button>
                    <button id="modalRegisterBtn" type="button" class="btn btn-primary">Register</button>
                    <button class="btn btn-secondary" type="button" data-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>


모달창은 모든 내용을 담고 각 작업에 맞게 버튼이나 입력창을 보이거나 감춘다.


    새로운 댓글의 추가 버튼 이벤트 처리

댓글 목록 상단에 'New Reply' 를 클릭하면 모달창이 보이게 처리한다.
모달 관련 객체들은 여러 함수로 사용할 것이니 바깥으로 빼두어 매번 jQuery 를 호출하지 않도록 한다.


    function showList(page) {
        ..
    }

    var modal = $('#replyModal');
    var modalInputReply = modal.find("input[name='reply']");
    var modalInputReplyer = modal.find("input[name='replyer']");
    var modalInputReplyDate = modal.find("input[name='replyDate']");

    var modalModBtn = $('#modalModBtn');
    var modalRemoveBtn = $('#modalRemoveBtn');
    var modalRegisterBtn = $('#modalRegisterBtn');

    $('#addReplyBtn').on("click", function(e) {
        modal.find("input").val("");
        modalInputReplyDate.closest("div").hide();
        modal.find("button[id != 'modalCloseBtn']").hide();

        modalRegisterBtn.show();

        $("#replyModal").modal("show");
    });


    댓글 등록 및 목록 갱신

새 댓글 추가는 필요한 내용과 작성자를 추가하여 'Register' 버튼을 클릭하여 처리한다.


    modalRegisterBtn.on("click", function(e) {
        let reply = {
            reply: modalInputReply.val(),
            replyer: modalInputReplyer.val(),
            bno: bnoValue
        };

        replyService.add(reply, function(result) {
            alert(result);

            modal.find("input").val();
            modal.modal("hide");
        });
    });


댓글을 정삭 추가하면 경고창으로 성공을 알리고 등록한 내용을 다시 등록 못하게 입력항목을 비운 후 모달창을 닫는다.

댓글 정상 처리 후 목록 자체는 갱신되지 않아 새로된 댓글이 보이지 않는다.
이 문제 때문에 댓글 추가 후 다시 댓글 목록(showList(1))을 갱신할 필요가 있다.


    modalRegisterBtn.on("click", function(e) {
        let reply = {
            reply: modalInputReply.val(),
            replyer: modalInputReplyer.val(),
            bno: bnoValue
        };

        replyService.add(reply, function(result) {
            alert(result);

            modal.find("input").val();
            modal.modal("hide");

            showList(1);
        });
    });


기존 코드에 showList(1) 을 추가하여 댓글 추가 후 새로운 댓글도 가져오도록 한다.


        17.5.3 특정 댓글 클릭 이벤트

댓글 목록에서 내용이 모두 추가되었으니 해당 댓글을 수정/삭제는 클릭하여 ㅓ리한다.
DOM 에서 이벤트 리스너 등록하는 것은 해당 DOM 요소가 존재해야 가능한데, 위 처럼 Ajax 로 <li> 태그들이 만들어지면
이후 이벤트 등록을 해야 하므로 일반적인 방식이 아닌 '이벤트 위임(delegation)'의 형태로 작성해야 한다.

'이벤트 위임' 은  이벤트를 동적으로 생성하는 것이 아닌 이미 존재하는 요소에 이벤트를 걸어주고,
나중에 이벤트 대상을 변경해 주는 방식이다. jQuery 는 on() 를 이용하여 쉽게 처리할 수 있다.


    $(".list-group").on("click", "li", function(e) {
        let rno = $(this).data("rno");
        console.log(rno);
    });


jQuery 이벤트 위임 방식은 이미 존재하는 DOM 요소에 이벤트를 처리 후 나중에 동적으로 생기는 요소에 대한 파라미터 형식으로 지정한다.
위 경우 '.list-group' 클래스로 이벤트를 걸고 실제 이벤트 대상은 안의 <li> 태그가 되도록 한다.

브라우저에 위 메이벤트를 확인해보면 각 댓글이 이벤트의 this 가 되어 댓글 번호가 나타나는 것을 확인할 수 있다.

위 코드가 정상 작동하면 댓글을 볼 수 있는 모달창을 처리해 준다.
모달창을 브라우저에서 보여주는 코드는 특정 댓글을 클릭했을 때 보여주도록 한다.


    // 댓글 조회 클릭 이벤트 처리
    $(".list-group").on("click", "li", function(e) {
        let rno = $(this).data("rno");

        replyService.get(rno, function(reply) {
            modalInputReply.val(reply.reply);
            modalInputReplyer.val(reply.replyer);
            modalInputReplyDate.val(replyService.displayTime(reply.replyDate))
                .attr("readonly", "readonly");
            modal.data("rno", reply.rno);

            modal.find("button[id != 'modalCloseBtn']").hide();
            modalModBtn.show();
            modalRemoveBtn.show();

            $('#replyModal').modal("show");
        });
    });


댓글 조회 행위는 모든 내용이 화면에 있어 별도로 조회할 필요는 없지만, Ajax 로 댓글 조회 후 수정/삭제가 정상이다.
댓글을 가져와 필요한 항목들을 채우고 수정과 삭제에 필요한 댓글 번호는 'data-rno' 속성으로 만들어 추가해 둔다.


        17.5.4 댓글 수정/삭제 이벤트 처리

댓글 삭제는 간단하게 결과를 보여주는 작업만 처리하면 되므로 가장 간단하게 처리할 수 있다.
삭제/수정 작업 모두 작업 끝난 후 다시 댓글 목록을 갱신해야 한다.


    modalModBtn.on("click", function(e) {
        var reply = {rno: modal.data('rno'), reply: modalInputReply.val()};

        replyService.update(reply, function(result) {
            alert(result);
            modal.modal("hide");
            showList(1);
        });
    })


댓글 삭제 역시 모달창 옆의 'data-rno' 값으로 처리한다.


    modalRemoveBtn.on("click", function(e) {
        var rno = modal.data("rno");

        replyService.remove(rno, function(result) {
            alert(result);
            modal.modal("hide");
            showList(1);
        });
    });


            17.6 댓글 페이징 처리

현재까지 전체 댓글을 한 화면에만 출력한다. 댓글 숫자가 많을 경우 성능상 문제가 가져올 수 있어 이 문제를 페이징 처리를 해야한다.


        17.6.1 데이터베이스 인덱스 설계

댓글에 고려해야할 일은 tbl_reply 테이블을 접근할 때 댓글 번호(rno)가 중심이 아닌, 게시물 번호(bno)가 중심이 되는 점이다.
댓글 조회 시 해당 게시물의 댓글을 가져오기 때문에 tbl_reply where bno = 200 order by rno asc' 와 같은 방식으로 접근한다.

tbl_reply 테이블의 PK 는 rno 이므로 위 방식으로 테이블을 접근하면 bno 값이 100번인 게시물의 댓글들을 보면
pk_reply 를 이용하여 검색하다 보니 중간에 다른 게시물 번호들을 건너 뛰어가며 특정 게시물의 댓글들을 찾아야 한다.
만일 데이터가 많아지면 문제가 생길 수 있다.

효율을 높이고 싶을 시 게시물의 번호에 맞게 댓글들을 빠르게 모아 찾는 구조도 좋다.
bno 별로 댓글을 모아두었다가 특정 게시물의 댓글을 찾을 때 이미 모여진 부분만을 찾게하는 것이 좋다.
이 구조를 이용하면 'bno = 200 order by rno asc' 같은 쿼리를 실행할 때 200 에 해당하는 범위만 찾아 사용하게 된다.(range scan)
이런 구조를 생성하는 것을 '인덱스를 생성한다' 고 표현한다. 위 구조를 만드는 인덱스는 다음과 같다.


    CREATE INDEX idx_reply ON tbl_reply (bno DESC, rno ASC);


        17.6.2 인덱스를 이용한 페이징 처리

인덱스 사용 이유 중 하나는 정렬을 피할 수 있기 때문이다.
특정 게시물의 rno 순번대로 테이블 조회하고 싶다면 다음 쿼리를 작성하게 된다.


    SELECT /*+ INDEX(tbl_reply idx_reply) */
    ROWNUM rn, bno, rno, reply, replyer, replyDate, updateDate
    FROM tbl_reply
    WHERE bno = 983052 -- (게시물 번호)
    AND rno > 0;


위 SQL 실행 계획은 'idx_reply' 를 이용하여 테이블에 접근하는 것을 볼 수 있다.
테이블 접근하여 결과를 만들 때 생성되는 ROWNUM 은 가장 낮은 rno 값을 가지는 데이터가 1번이 되게 된다.

ROWNUM 이 원하는 순서대로 나와서 페이징 처리는 이전 게시물 페이징과 동일한 형태로 작성할 수 있다.
예로 10개씩 2페이지를 가져오면 다음 쿼리를 작성하게 된다.


    SELECT rno, bno, reply, replyer, replydate, updatedate
    FROM (
        SELECT /*+ INDEX(tbl_board idx_reply) */
        ROWNUM rn, bno, rno, reply, replyer, replydate, updatedate
        FROM tbl_reply
        WHERE bno = 게시물 번호 AND rno > 0 AND ROWNUM <= 20 )
    WHERE rn > 10;


ReplyMapper.xml 위 내용을 반영해보자.


    <select id="getListWithPaging" resultType="domain.ReplyVO">
        <![CDATA[
            SELECT rno, bno, reply, replyer, replydate, updatedate
            FROM (
                SELECT /*+ INDEX(tbl_board idx_reply) */
                ROWNUM rn, bno, rno, reply, replyer, replydate, updatedate
                FROM tbl_reply
                WHERE bno = #{bno}
                AND rno > 0
                AND ROWNUM <= ${cri.pageNum} * #{cri.amount} )
            WHERE rn > (#{cri.pageNum} - 1) * #{cri.amount}
        ]]>
    </select>


ReplyMapper.xml 페이징 처리는 테스트 코드로 결과를 확인한다.


    @Test
    public void testList2() {
        Criteria cri = new Criteria(2, 10);

        // 983052
        List<ReplyVO> replies = mapper.getListWithPaging(cri, 983052L);
        replies.forEach(reply -> log.info(reply));
    }


테스트 결과는 2 페이지에 해당하는 게시물인지 확인하자.


        17.6.3 댓글 숫자 파악

댓글 페이징 처리는 해당 게시물의 전체 댓글의 숫자를 파악하여 화면에 보여줄 필요가 있다.
ReplyMapper 인터페이스와 ReplyMapper.xml 에 getCountByBno() 를 추가한다.


    public int getCountByBno(Long bno);


ReplyMapper.xml 에는 id 가 getCountByBno 를 추가한다.


    <select id="getCountByBno" resultType="int">
        <![CDATA[
            SELECT COUNT(rno) FROM tbl_reply WHERE bno = #{bno}
        ]]>
    </select>


        17.6.4 ReplyServiceImpl 에서 댓글과 댓글 수 처리

단순 댓글 전체를 보여주는 방식은 페이징 처리가 필요하여 댓글 목록과 전체 댓글 수를 같이 전달해야 한다.
ReplyService 인터페이스와 구현 클래스 ReplyServiceImpl 는 List<ReplyVO> 와 댓글 수를 같이 전달하는 구조로 변경한다.

우선 'src/main/java/domin' 패키지에 두 자기 정보를 담을 수 있는 ReplyPageDTO 클래스를 정의한다.


    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.Getter;

    import java.util.List;

    @Data
    @AllArgsConstructor
    @Getter
    public class ReplyPageDTO {
        private int replyCnt;
        private List<ReplyVO> list;
    }


ReplyPageDTO 생성에 편하도록 @AllArgsConstructor 를 이용하여 replyCnt 와 list 를 자동 처리했다.
ReplyService 와 ReplyServiceImpl 클래스에 ReplyPageDTO 를 반환하는 메소드를 추가한다.


    ReplyService 인터페이스

    public ReplyPageDTO getListPage(Criteria cri, Long bno);


    ReplyServiceImpl 클래스

    @Override
    public ReplyPageDTO getListPage(Criteria cri, Long bno) {
        return new ReplyPageDTO(
                mapper.getCountByBno(bno),
                mapper.getListWithPaging(cri, bno));
    }


        17.6.5 ReplyController 수정

ReplyController 에서 ReplyService 의 새 메소드 getListPage()를 호출하고 데이터를 전송하는 형태로 수정한다.


    @GetMapping(value = "/pages/{bno}/{page}", produces = {MediaType.APPLICATION_XML_VALUE,
            MediaType.APPLICATION_JSON_UTF8_VALUE})
    public ResponseEntity<ReplyPageDTO> getList(
            @PathVariable("page") int page,
            @PathVariable("bno") Long bno) {
        Criteria cri = new Criteria(page, 10);

        log.info("get Reply List bno: " + bno);
        log.info("cri" + cri);

        return new ResponseEntity<>(service.getListPage(cri, bno), HttpStatus.OK);
    }


ReplyPageDTO 객체를 전송하여 특정 게시물의 댓글 목록 조회 시에 'replyCnt' 와 'list' 라는 이름의 속성을 가진 JSON 문자열이 전송된다.


            17.7 댓글 페이지의 화면 처리

댓글 처리 화면은 다음 방식으로  진행된다.


    - 게시물 조회 페이지에 들어오면 가장 오래된 댓글을 가져와 1페이지에 보여준다.
    - 1페이지 게시물 가져올 때마다 댓글 숫자를 파악하여 댓글의 페이지 번호를 출력한다.
    - 댓글 추가 시 댓글 숫자만 가져와서 최종 페이지를 찾아 이동한다.
    - 댓글 수정과 삭제 후엔 다시 동일 페이지를 호출한다.


        17.7.1 댓글 페이지 계산과 출력

Ajax 로 가져온 데이터가 replyCnt 와 list 란 데이터로 구성되므로 이를 처리할 reply.js 내용 역시 이를 처리하는 구조로 수정한다.


    function getList(param, callback, error) {
        var bno = param.bno;
        var page = param.page || 1;
        $.getJSON("/replies/pages/" + bno + "/" + page + ".json",
            function(data) {
                if(callback) {
                    // callback(data);  // 목록만 가져오는 경우
                    callback(data.replyCnt, data.list); // 댓글 숫자와 목록을 가져오는 경우
                }
            }).fail(function(xhr, status, err) {
            if(error) {
                error();
            }
        });
    }


기본에 비해 callback 함수에 댓글 수(replyCnt)와 페이지에 해당하는 댓글 데이터를 전달하도록 하였다.
reply.js 를 이용하여 댓글 페이지를 호출하는 부분은 showList 함수이므로 페이지 번호를 출력하도록 수정한다.


    function showList(page) {

        console.log("show list " + page);

        replyService.getList({bno: bnoValue, page: page || 1}, function(replyCnt, list) {

            console.log("replyCnt: " + replyCnt);
            console.log("list: " + list);
            console.log(list);

            if(page == -1) {
                let pageNum = Math.ceil(replyCnt / 10.0);
                showList(pageNum);
                return;
            }

            var str = "";
            if(list == null || list.length == 0) {
                replyUL.html("");
                return;
            }

            for(let i = 0, len = list.length || 0; i < len; i++) {
                str += "<li class='list-group-item clearfix' data-rno='" + list[i].rno + "'>";
                str += "<div><div class='header'><strong class='text-primary'>[" +
                    list[i].rno + "]" + list[i].replyer + "</strong>";
                str += "<small class='float-right text-muted'>" +
                    replyService.displayTime(list[i].replyDate) + "</small></div>";
                str += "<p>" + list[i].reply + "</p></div></li>";
            }

            replyUL.html(str);
        });
    }


showList() 함수는 파라미터로 page 변수를 이용하여 원하는 댓글 페이지를 가져온다.
만일 page 번호가 '-1' 이 전달되면 마지막 페이지를 찾아 다시 호출된다.
사용자가 새 댓글을 showList(-1); 을 호출하여 우선 전체 댓글 숫자를 파악한다. 이후 다시 마지막 페이지를 호출하여 이동하는 방식이다.
이 방식은 여러 번 서버를 호출해야하는 단점이 있지만 댓글 행위가 댓글 조회나 페이징에 비해 적기 때문에 심각하진 않다.


    modalRegisterBtn.on("click", function(e) {

        let reply = {
            reply: modalInputReply.val(),
            replyer: modalInputReplyer.val(),
            bno: bnoValue
        };

        replyService.add(reply, function(result) {
            alert(result);

            modal.find("input").val();
            modal.modal("hide");

            // showList(1);
            showList(-1);
        });
    });


댓글은 화면상에 댓글이 출력되는 영역 아래에 <div class='card-footer'> 를 추가한다.
추가된 <div> 태그에 페이지 번호를 출력하는 로직은 showReplyPage()를 작성한다.


    var pageNum = 1;
    var replyCardFooter = $('.card-footer');

    function showReplyPage(replyCnt) {
        var endNum = Math.ceil(pageNum / 10.0) * 10;
        var startNum = endNum - 9;

        var prev = startNum != 1;
        var next = false;

        if(endNum * 10 >= replyCnt) {
            endNum = Math.ceil(replyCnt / 10.0);
        }

        if(endNum * 10 < replyCnt) {
            next = true;
        }

        var str = "<ul class='pagination float-right'>";

        if(prev) {
            str += "<li class='page-item'><a class='page-link' href='" + (startNum - 1) + "'>Previous</a></li>";
        }

        for(let i = startNum; i <= endNum; i++) {
            var active = pageNum == i ? "active" : "";

            str += "<li class='page-item " + active +"'><a class='page-link' href='" + i + "'>" + i + "</a></li>";
        }

        if(next) {
            str += "<li class='page-item'><a class='page-link' href='" + (endNum + 1) + "'>Next</a></li>";
        }

        str += "</ul></li>";

        console.log(str);

        replyCardFooter.html(str);
    }


showReplyPage()는 기존 Java 의 PageMaker 의 JavaScript 버전에 해당한다.
댓글 페이지를 문자열로 구성 후 <div> 의 innerHTML 로 추가한다. showList() 마지막 페이지를 출력하도록 수정한다.


    for(let i = 0, len = list.length || 0; i < len; i++) {
        ...
    }

    replyUL.html(str);

    showReplyPage(replyCnt);


마지막 처리는 페이지 번호 클릭 시 새로운 댓글을 가져오는 부분이다.


    replyCardFooter.on("click", "li a", function(e) {
        e.preventDefault();

        let targetPageNum = $(this).attr("href");

        console.log("targetPageNum: " + targetPageNum);

        pageNum = targetPageNum;

        showList(pageNum);
    });


댓글 페이지 번호는 <a> 태그 내에 존재하여 이벤트 처리는 <a> 태그 기본 동작을 제한하고 댓글 페이지 번호를
변경 후 해당 페이지의 댓글을 가져온다.


        17.7.2 댓글 수정/삭제

댓글 페이지 처리되면 댓글 수정과 삭제 시에도 현재 댓글이 포함된 페이지로 이동하도록 수정한다.


    modalModBtn.on("click", function(e) {
        var reply = {rno: modal.data('rno'), reply: modalInputReply.val()};

        replyService.update(reply, function(result) {
            alert(result);
            modal.modal("hide");
            showList(pageNum);
        });
    });

    modalRemoveBtn.on("click", function(e) {
        var rno = modal.data("rno");

        replyService.remove(rno, function(result) {
            alert(result);
            modal.modal("hide");
            showList(pageNum);
        });
    });


기존과 달리 showList() 호출 시 현재 보고 있는 댓글 페이지의 번호를 호출하는 점이다.
브라우저에 댓글 등록, 수정, 삭제 작업을 해보자.